/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* start:= start = grammar $
* grammar := declaration|assign|array|exp
* TkSemicolon := value = 'TkSemicolon '
* TkNumber := value = 'TkNumber\([0-9]+(?:\.[0-9]+)?\) '
* TkId := value = 'TkId\(\b([a-zA-Z_][^\s\W]*)\) '
* TkAssign := value = 'TkAssign '
* TkOpenPar := value = 'TkOpenPar '
* TkClosePar := value = 'TkClosePar '
* TkOpenBracket := value = 'TkOpenBracket '
* TkCloseBracket := value = 'TkCloseBracket '
* TkOpenBrace := value = 'TkOpenBrace '
* TkCloseBrace := value = 'TkCloseBrace '
* TkPower := value = 'TkPower '
* TkPlus := value = 'TkPlus '
* TkMinus := value = 'TkMinus '
* TkMult := value = 'TkMult '
* TkDiv := value = 'TkDiv '
* TkAnd := value = 'TkAnd '
* TkOr := value = 'TkOr '
* TkNot := value = 'TkNot '
* TkMod := value = 'TkMod '
* TkLT := value = 'TkLT '
* TkLE := value = 'TkLE '
* TkGE := value = 'TkGE '
* TkGT := value = 'TkGT '
* TkEQ := value = 'TkEQ '
* TkNE := value = 'TkNE '
* TkComma := value = 'TkComma '
* TkNum := value = 'TkNum '
* TkBool := value = 'TkBool '
* TkQuote := value = 'TkQuote '
* TkFalse := value = 'TkFalse '
* TkTrue := value = 'TkTrue '
* TkBoolean := TkFalse | TkTrue
* Type := TkNum | TkBool
* lambda := value = ''
* space := ' ' | '\\t' | '\n' | '\r\n'
* declaration := space* type=Type space* id=TkId space* symbol=TkAssign space* e=exp space* TkSemicolon space*
* assign := space* id=TkId space* a={TkOpenBracket next=exp TkCloseBracket}? space* symbol=TkAssign space* e=exp space* TkSemicolon space*
* array := space* p1=TkOpenBracket space* type=Type space* p2=TkCloseBracket space* id=TkId space* symbol=TkAssign space* e=exp space* TkSemicolon space*
* unary := TkPlus | TkMinus | TkNot 
* terms := TkNumber | TkBoolean | value=TkId a={TkOpenBracket next=exp TkCloseBracket}? b={TkOpenPar next=termino? TkClosePar}?
* exp := space* e=e1 space*
* e1 := e=e2 space* a={op={TkAnd | TkOr} next=e2}*
* e2 := e=e3 space* a={op={TkEQ | TkNE} next=e3}*
* e3 := e=e4 space* a={op={TkLT | TkLE | TkGE | TkGT} next=e4}*
* e4 := e=e5 space* a={op={TkPlus | TkMinus} next=e5}*
* e5 := e=e6 space* a={op={TkMult | TkDiv | TkMod} next=e6}*
* e6 := uop=unary* space* e=e7 space*
* e7 := e=e8 space* a={op={TkPower} next=e8}*
* e8 := TkOpenPar space* value=exp space* TkClosePar | TkOpenBracket space* value=termino? space* TkCloseBracket | TkOpenBrace space* value=exp space* TkCloseBrace | TkQuote space* value=exp space* TkQuote | terms
* termino := space* e=exp space* b={TkComma e=exp}* space*
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    start = "start",
    grammar_1 = "grammar_1",
    grammar_2 = "grammar_2",
    grammar_3 = "grammar_3",
    grammar_4 = "grammar_4",
    TkSemicolon = "TkSemicolon",
    TkNumber = "TkNumber",
    TkId = "TkId",
    TkAssign = "TkAssign",
    TkOpenPar = "TkOpenPar",
    TkClosePar = "TkClosePar",
    TkOpenBracket = "TkOpenBracket",
    TkCloseBracket = "TkCloseBracket",
    TkOpenBrace = "TkOpenBrace",
    TkCloseBrace = "TkCloseBrace",
    TkPower = "TkPower",
    TkPlus = "TkPlus",
    TkMinus = "TkMinus",
    TkMult = "TkMult",
    TkDiv = "TkDiv",
    TkAnd = "TkAnd",
    TkOr = "TkOr",
    TkNot = "TkNot",
    TkMod = "TkMod",
    TkLT = "TkLT",
    TkLE = "TkLE",
    TkGE = "TkGE",
    TkGT = "TkGT",
    TkEQ = "TkEQ",
    TkNE = "TkNE",
    TkComma = "TkComma",
    TkNum = "TkNum",
    TkBool = "TkBool",
    TkQuote = "TkQuote",
    TkFalse = "TkFalse",
    TkTrue = "TkTrue",
    TkBoolean_1 = "TkBoolean_1",
    TkBoolean_2 = "TkBoolean_2",
    Type_1 = "Type_1",
    Type_2 = "Type_2",
    lambda = "lambda",
    space_1 = "space_1",
    space_2 = "space_2",
    space_3 = "space_3",
    space_4 = "space_4",
    declaration = "declaration",
    assign = "assign",
    assign_$0 = "assign_$0",
    array = "array",
    unary_1 = "unary_1",
    unary_2 = "unary_2",
    unary_3 = "unary_3",
    terms_1 = "terms_1",
    terms_2 = "terms_2",
    terms_3 = "terms_3",
    terms_$0 = "terms_$0",
    terms_$1 = "terms_$1",
    exp = "exp",
    e1 = "e1",
    e1_$0 = "e1_$0",
    e1_$0_$0_1 = "e1_$0_$0_1",
    e1_$0_$0_2 = "e1_$0_$0_2",
    e2 = "e2",
    e2_$0 = "e2_$0",
    e2_$0_$0_1 = "e2_$0_$0_1",
    e2_$0_$0_2 = "e2_$0_$0_2",
    e3 = "e3",
    e3_$0 = "e3_$0",
    e3_$0_$0_1 = "e3_$0_$0_1",
    e3_$0_$0_2 = "e3_$0_$0_2",
    e3_$0_$0_3 = "e3_$0_$0_3",
    e3_$0_$0_4 = "e3_$0_$0_4",
    e4 = "e4",
    e4_$0 = "e4_$0",
    e4_$0_$0_1 = "e4_$0_$0_1",
    e4_$0_$0_2 = "e4_$0_$0_2",
    e5 = "e5",
    e5_$0 = "e5_$0",
    e5_$0_$0_1 = "e5_$0_$0_1",
    e5_$0_$0_2 = "e5_$0_$0_2",
    e5_$0_$0_3 = "e5_$0_$0_3",
    e6 = "e6",
    e7 = "e7",
    e7_$0 = "e7_$0",
    e7_$0_$0 = "e7_$0_$0",
    e8_1 = "e8_1",
    e8_2 = "e8_2",
    e8_3 = "e8_3",
    e8_4 = "e8_4",
    e8_5 = "e8_5",
    termino = "termino",
    termino_$0 = "termino_$0",
    $EOF = "$EOF",
}
export interface start {
    kind: ASTKinds.start;
    start: grammar;
}
export type grammar = grammar_1 | grammar_2 | grammar_3 | grammar_4;
export type grammar_1 = declaration;
export type grammar_2 = assign;
export type grammar_3 = array;
export type grammar_4 = exp;
export interface TkSemicolon {
    kind: ASTKinds.TkSemicolon;
    value: string;
}
export interface TkNumber {
    kind: ASTKinds.TkNumber;
    value: string;
}
export interface TkId {
    kind: ASTKinds.TkId;
    value: string;
}
export interface TkAssign {
    kind: ASTKinds.TkAssign;
    value: string;
}
export interface TkOpenPar {
    kind: ASTKinds.TkOpenPar;
    value: string;
}
export interface TkClosePar {
    kind: ASTKinds.TkClosePar;
    value: string;
}
export interface TkOpenBracket {
    kind: ASTKinds.TkOpenBracket;
    value: string;
}
export interface TkCloseBracket {
    kind: ASTKinds.TkCloseBracket;
    value: string;
}
export interface TkOpenBrace {
    kind: ASTKinds.TkOpenBrace;
    value: string;
}
export interface TkCloseBrace {
    kind: ASTKinds.TkCloseBrace;
    value: string;
}
export interface TkPower {
    kind: ASTKinds.TkPower;
    value: string;
}
export interface TkPlus {
    kind: ASTKinds.TkPlus;
    value: string;
}
export interface TkMinus {
    kind: ASTKinds.TkMinus;
    value: string;
}
export interface TkMult {
    kind: ASTKinds.TkMult;
    value: string;
}
export interface TkDiv {
    kind: ASTKinds.TkDiv;
    value: string;
}
export interface TkAnd {
    kind: ASTKinds.TkAnd;
    value: string;
}
export interface TkOr {
    kind: ASTKinds.TkOr;
    value: string;
}
export interface TkNot {
    kind: ASTKinds.TkNot;
    value: string;
}
export interface TkMod {
    kind: ASTKinds.TkMod;
    value: string;
}
export interface TkLT {
    kind: ASTKinds.TkLT;
    value: string;
}
export interface TkLE {
    kind: ASTKinds.TkLE;
    value: string;
}
export interface TkGE {
    kind: ASTKinds.TkGE;
    value: string;
}
export interface TkGT {
    kind: ASTKinds.TkGT;
    value: string;
}
export interface TkEQ {
    kind: ASTKinds.TkEQ;
    value: string;
}
export interface TkNE {
    kind: ASTKinds.TkNE;
    value: string;
}
export interface TkComma {
    kind: ASTKinds.TkComma;
    value: string;
}
export interface TkNum {
    kind: ASTKinds.TkNum;
    value: string;
}
export interface TkBool {
    kind: ASTKinds.TkBool;
    value: string;
}
export interface TkQuote {
    kind: ASTKinds.TkQuote;
    value: string;
}
export interface TkFalse {
    kind: ASTKinds.TkFalse;
    value: string;
}
export interface TkTrue {
    kind: ASTKinds.TkTrue;
    value: string;
}
export type TkBoolean = TkBoolean_1 | TkBoolean_2;
export type TkBoolean_1 = TkFalse;
export type TkBoolean_2 = TkTrue;
export type Type = Type_1 | Type_2;
export type Type_1 = TkNum;
export type Type_2 = TkBool;
export interface lambda {
    kind: ASTKinds.lambda;
    value: string;
}
export type space = space_1 | space_2 | space_3 | space_4;
export type space_1 = string;
export type space_2 = string;
export type space_3 = string;
export type space_4 = string;
export interface declaration {
    kind: ASTKinds.declaration;
    type: Type;
    id: TkId;
    symbol: TkAssign;
    e: exp;
}
export interface assign {
    kind: ASTKinds.assign;
    id: TkId;
    a: Nullable<assign_$0>;
    symbol: TkAssign;
    e: exp;
}
export interface assign_$0 {
    kind: ASTKinds.assign_$0;
    next: exp;
}
export interface array {
    kind: ASTKinds.array;
    p1: TkOpenBracket;
    type: Type;
    p2: TkCloseBracket;
    id: TkId;
    symbol: TkAssign;
    e: exp;
}
export type unary = unary_1 | unary_2 | unary_3;
export type unary_1 = TkPlus;
export type unary_2 = TkMinus;
export type unary_3 = TkNot;
export type terms = terms_1 | terms_2 | terms_3;
export type terms_1 = TkNumber;
export type terms_2 = TkBoolean;
export interface terms_3 {
    kind: ASTKinds.terms_3;
    value: TkId;
    a: Nullable<terms_$0>;
    b: Nullable<terms_$1>;
}
export interface terms_$0 {
    kind: ASTKinds.terms_$0;
    next: exp;
}
export interface terms_$1 {
    kind: ASTKinds.terms_$1;
    next: Nullable<termino>;
}
export interface exp {
    kind: ASTKinds.exp;
    e: e1;
}
export interface e1 {
    kind: ASTKinds.e1;
    e: e2;
    a: e1_$0[];
}
export interface e1_$0 {
    kind: ASTKinds.e1_$0;
    op: e1_$0_$0;
    next: e2;
}
export type e1_$0_$0 = e1_$0_$0_1 | e1_$0_$0_2;
export type e1_$0_$0_1 = TkAnd;
export type e1_$0_$0_2 = TkOr;
export interface e2 {
    kind: ASTKinds.e2;
    e: e3;
    a: e2_$0[];
}
export interface e2_$0 {
    kind: ASTKinds.e2_$0;
    op: e2_$0_$0;
    next: e3;
}
export type e2_$0_$0 = e2_$0_$0_1 | e2_$0_$0_2;
export type e2_$0_$0_1 = TkEQ;
export type e2_$0_$0_2 = TkNE;
export interface e3 {
    kind: ASTKinds.e3;
    e: e4;
    a: e3_$0[];
}
export interface e3_$0 {
    kind: ASTKinds.e3_$0;
    op: e3_$0_$0;
    next: e4;
}
export type e3_$0_$0 = e3_$0_$0_1 | e3_$0_$0_2 | e3_$0_$0_3 | e3_$0_$0_4;
export type e3_$0_$0_1 = TkLT;
export type e3_$0_$0_2 = TkLE;
export type e3_$0_$0_3 = TkGE;
export type e3_$0_$0_4 = TkGT;
export interface e4 {
    kind: ASTKinds.e4;
    e: e5;
    a: e4_$0[];
}
export interface e4_$0 {
    kind: ASTKinds.e4_$0;
    op: e4_$0_$0;
    next: e5;
}
export type e4_$0_$0 = e4_$0_$0_1 | e4_$0_$0_2;
export type e4_$0_$0_1 = TkPlus;
export type e4_$0_$0_2 = TkMinus;
export interface e5 {
    kind: ASTKinds.e5;
    e: e6;
    a: e5_$0[];
}
export interface e5_$0 {
    kind: ASTKinds.e5_$0;
    op: e5_$0_$0;
    next: e6;
}
export type e5_$0_$0 = e5_$0_$0_1 | e5_$0_$0_2 | e5_$0_$0_3;
export type e5_$0_$0_1 = TkMult;
export type e5_$0_$0_2 = TkDiv;
export type e5_$0_$0_3 = TkMod;
export interface e6 {
    kind: ASTKinds.e6;
    uop: unary[];
    e: e7;
}
export interface e7 {
    kind: ASTKinds.e7;
    e: e8;
    a: e7_$0[];
}
export interface e7_$0 {
    kind: ASTKinds.e7_$0;
    op: e7_$0_$0;
    next: e8;
}
export type e7_$0_$0 = TkPower;
export type e8 = e8_1 | e8_2 | e8_3 | e8_4 | e8_5;
export interface e8_1 {
    kind: ASTKinds.e8_1;
    value: exp;
}
export interface e8_2 {
    kind: ASTKinds.e8_2;
    value: Nullable<termino>;
}
export interface e8_3 {
    kind: ASTKinds.e8_3;
    value: exp;
}
export interface e8_4 {
    kind: ASTKinds.e8_4;
    value: exp;
}
export type e8_5 = terms;
export interface termino {
    kind: ASTKinds.termino;
    e: exp;
    b: termino_$0[];
}
export interface termino_$0 {
    kind: ASTKinds.termino_$0;
    e: exp;
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchstart($$dpth: number, $$cr?: ErrorTracker): Nullable<start> {
        return this.run<start>($$dpth,
            () => {
                let $scope$start: Nullable<grammar>;
                let $$res: Nullable<start> = null;
                if (true
                    && ($scope$start = this.matchgrammar($$dpth + 1, $$cr)) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.start, start: $scope$start};
                }
                return $$res;
            });
    }
    public matchgrammar($$dpth: number, $$cr?: ErrorTracker): Nullable<grammar> {
        return this.choice<grammar>([
            () => this.matchgrammar_1($$dpth + 1, $$cr),
            () => this.matchgrammar_2($$dpth + 1, $$cr),
            () => this.matchgrammar_3($$dpth + 1, $$cr),
            () => this.matchgrammar_4($$dpth + 1, $$cr),
        ]);
    }
    public matchgrammar_1($$dpth: number, $$cr?: ErrorTracker): Nullable<grammar_1> {
        return this.matchdeclaration($$dpth + 1, $$cr);
    }
    public matchgrammar_2($$dpth: number, $$cr?: ErrorTracker): Nullable<grammar_2> {
        return this.matchassign($$dpth + 1, $$cr);
    }
    public matchgrammar_3($$dpth: number, $$cr?: ErrorTracker): Nullable<grammar_3> {
        return this.matcharray($$dpth + 1, $$cr);
    }
    public matchgrammar_4($$dpth: number, $$cr?: ErrorTracker): Nullable<grammar_4> {
        return this.matchexp($$dpth + 1, $$cr);
    }
    public matchTkSemicolon($$dpth: number, $$cr?: ErrorTracker): Nullable<TkSemicolon> {
        return this.run<TkSemicolon>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkSemicolon> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkSemicolon )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkSemicolon, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkNumber($$dpth: number, $$cr?: ErrorTracker): Nullable<TkNumber> {
        return this.run<TkNumber>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkNumber> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkNumber\([0-9]+(?:\.[0-9]+)?\) )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkNumber, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkId($$dpth: number, $$cr?: ErrorTracker): Nullable<TkId> {
        return this.run<TkId>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkId> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkId\(\b([a-zA-Z_][^\s\W]*)\) )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkId, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkAssign($$dpth: number, $$cr?: ErrorTracker): Nullable<TkAssign> {
        return this.run<TkAssign>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkAssign> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkAssign )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkAssign, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkOpenPar($$dpth: number, $$cr?: ErrorTracker): Nullable<TkOpenPar> {
        return this.run<TkOpenPar>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkOpenPar> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkOpenPar )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkOpenPar, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkClosePar($$dpth: number, $$cr?: ErrorTracker): Nullable<TkClosePar> {
        return this.run<TkClosePar>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkClosePar> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkClosePar )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkClosePar, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkOpenBracket($$dpth: number, $$cr?: ErrorTracker): Nullable<TkOpenBracket> {
        return this.run<TkOpenBracket>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkOpenBracket> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkOpenBracket )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkOpenBracket, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkCloseBracket($$dpth: number, $$cr?: ErrorTracker): Nullable<TkCloseBracket> {
        return this.run<TkCloseBracket>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkCloseBracket> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkCloseBracket )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkCloseBracket, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkOpenBrace($$dpth: number, $$cr?: ErrorTracker): Nullable<TkOpenBrace> {
        return this.run<TkOpenBrace>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkOpenBrace> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkOpenBrace )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkOpenBrace, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkCloseBrace($$dpth: number, $$cr?: ErrorTracker): Nullable<TkCloseBrace> {
        return this.run<TkCloseBrace>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkCloseBrace> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkCloseBrace )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkCloseBrace, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkPower($$dpth: number, $$cr?: ErrorTracker): Nullable<TkPower> {
        return this.run<TkPower>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkPower> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkPower )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkPower, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkPlus($$dpth: number, $$cr?: ErrorTracker): Nullable<TkPlus> {
        return this.run<TkPlus>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkPlus> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkPlus )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkPlus, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<TkMinus> {
        return this.run<TkMinus>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkMinus> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkMinus )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkMinus, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkMult($$dpth: number, $$cr?: ErrorTracker): Nullable<TkMult> {
        return this.run<TkMult>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkMult> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkMult )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkMult, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkDiv($$dpth: number, $$cr?: ErrorTracker): Nullable<TkDiv> {
        return this.run<TkDiv>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkDiv> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkDiv )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkDiv, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<TkAnd> {
        return this.run<TkAnd>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkAnd> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkAnd )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkAnd, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkOr($$dpth: number, $$cr?: ErrorTracker): Nullable<TkOr> {
        return this.run<TkOr>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkOr> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkOr )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkOr, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkNot($$dpth: number, $$cr?: ErrorTracker): Nullable<TkNot> {
        return this.run<TkNot>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkNot> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkNot )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkNot, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkMod($$dpth: number, $$cr?: ErrorTracker): Nullable<TkMod> {
        return this.run<TkMod>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkMod> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkMod )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkMod, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkLT($$dpth: number, $$cr?: ErrorTracker): Nullable<TkLT> {
        return this.run<TkLT>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkLT> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkLT )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkLT, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkLE($$dpth: number, $$cr?: ErrorTracker): Nullable<TkLE> {
        return this.run<TkLE>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkLE> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkLE )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkLE, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkGE($$dpth: number, $$cr?: ErrorTracker): Nullable<TkGE> {
        return this.run<TkGE>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkGE> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkGE )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkGE, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkGT($$dpth: number, $$cr?: ErrorTracker): Nullable<TkGT> {
        return this.run<TkGT>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkGT> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkGT )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkGT, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkEQ($$dpth: number, $$cr?: ErrorTracker): Nullable<TkEQ> {
        return this.run<TkEQ>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkEQ> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkEQ )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkEQ, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkNE($$dpth: number, $$cr?: ErrorTracker): Nullable<TkNE> {
        return this.run<TkNE>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkNE> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkNE )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkNE, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkComma($$dpth: number, $$cr?: ErrorTracker): Nullable<TkComma> {
        return this.run<TkComma>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkComma> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkComma )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkComma, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkNum($$dpth: number, $$cr?: ErrorTracker): Nullable<TkNum> {
        return this.run<TkNum>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkNum> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkNum )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkNum, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkBool($$dpth: number, $$cr?: ErrorTracker): Nullable<TkBool> {
        return this.run<TkBool>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkBool> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkBool )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkBool, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkQuote($$dpth: number, $$cr?: ErrorTracker): Nullable<TkQuote> {
        return this.run<TkQuote>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkQuote> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkQuote )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkQuote, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkFalse($$dpth: number, $$cr?: ErrorTracker): Nullable<TkFalse> {
        return this.run<TkFalse>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkFalse> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkFalse )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkFalse, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkTrue($$dpth: number, $$cr?: ErrorTracker): Nullable<TkTrue> {
        return this.run<TkTrue>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<TkTrue> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:TkTrue )`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkTrue, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchTkBoolean($$dpth: number, $$cr?: ErrorTracker): Nullable<TkBoolean> {
        return this.choice<TkBoolean>([
            () => this.matchTkBoolean_1($$dpth + 1, $$cr),
            () => this.matchTkBoolean_2($$dpth + 1, $$cr),
        ]);
    }
    public matchTkBoolean_1($$dpth: number, $$cr?: ErrorTracker): Nullable<TkBoolean_1> {
        return this.matchTkFalse($$dpth + 1, $$cr);
    }
    public matchTkBoolean_2($$dpth: number, $$cr?: ErrorTracker): Nullable<TkBoolean_2> {
        return this.matchTkTrue($$dpth + 1, $$cr);
    }
    public matchType($$dpth: number, $$cr?: ErrorTracker): Nullable<Type> {
        return this.choice<Type>([
            () => this.matchType_1($$dpth + 1, $$cr),
            () => this.matchType_2($$dpth + 1, $$cr),
        ]);
    }
    public matchType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Type_1> {
        return this.matchTkNum($$dpth + 1, $$cr);
    }
    public matchType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Type_2> {
        return this.matchTkBool($$dpth + 1, $$cr);
    }
    public matchlambda($$dpth: number, $$cr?: ErrorTracker): Nullable<lambda> {
        return this.run<lambda>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<lambda> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.lambda, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchspace($$dpth: number, $$cr?: ErrorTracker): Nullable<space> {
        return this.choice<space>([
            () => this.matchspace_1($$dpth + 1, $$cr),
            () => this.matchspace_2($$dpth + 1, $$cr),
            () => this.matchspace_3($$dpth + 1, $$cr),
            () => this.matchspace_4($$dpth + 1, $$cr),
        ]);
    }
    public matchspace_1($$dpth: number, $$cr?: ErrorTracker): Nullable<space_1> {
        return this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr);
    }
    public matchspace_2($$dpth: number, $$cr?: ErrorTracker): Nullable<space_2> {
        return this.regexAccept(String.raw`(?:\\t)`, $$dpth + 1, $$cr);
    }
    public matchspace_3($$dpth: number, $$cr?: ErrorTracker): Nullable<space_3> {
        return this.regexAccept(String.raw`(?:\n)`, $$dpth + 1, $$cr);
    }
    public matchspace_4($$dpth: number, $$cr?: ErrorTracker): Nullable<space_4> {
        return this.regexAccept(String.raw`(?:\r\n)`, $$dpth + 1, $$cr);
    }
    public matchdeclaration($$dpth: number, $$cr?: ErrorTracker): Nullable<declaration> {
        return this.run<declaration>($$dpth,
            () => {
                let $scope$type: Nullable<Type>;
                let $scope$id: Nullable<TkId>;
                let $scope$symbol: Nullable<TkAssign>;
                let $scope$e: Nullable<exp>;
                let $$res: Nullable<declaration> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$type = this.matchType($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$id = this.matchTkId($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$symbol = this.matchTkAssign($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$e = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && this.matchTkSemicolon($$dpth + 1, $$cr) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                ) {
                    $$res = {kind: ASTKinds.declaration, type: $scope$type, id: $scope$id, symbol: $scope$symbol, e: $scope$e};
                }
                return $$res;
            });
    }
    public matchassign($$dpth: number, $$cr?: ErrorTracker): Nullable<assign> {
        return this.run<assign>($$dpth,
            () => {
                let $scope$id: Nullable<TkId>;
                let $scope$a: Nullable<Nullable<assign_$0>>;
                let $scope$symbol: Nullable<TkAssign>;
                let $scope$e: Nullable<exp>;
                let $$res: Nullable<assign> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$id = this.matchTkId($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && (($scope$a = this.matchassign_$0($$dpth + 1, $$cr)) || true)
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$symbol = this.matchTkAssign($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$e = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && this.matchTkSemicolon($$dpth + 1, $$cr) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                ) {
                    $$res = {kind: ASTKinds.assign, id: $scope$id, a: $scope$a, symbol: $scope$symbol, e: $scope$e};
                }
                return $$res;
            });
    }
    public matchassign_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<assign_$0> {
        return this.run<assign_$0>($$dpth,
            () => {
                let $scope$next: Nullable<exp>;
                let $$res: Nullable<assign_$0> = null;
                if (true
                    && this.matchTkOpenBracket($$dpth + 1, $$cr) !== null
                    && ($scope$next = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.matchTkCloseBracket($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.assign_$0, next: $scope$next};
                }
                return $$res;
            });
    }
    public matcharray($$dpth: number, $$cr?: ErrorTracker): Nullable<array> {
        return this.run<array>($$dpth,
            () => {
                let $scope$p1: Nullable<TkOpenBracket>;
                let $scope$type: Nullable<Type>;
                let $scope$p2: Nullable<TkCloseBracket>;
                let $scope$id: Nullable<TkId>;
                let $scope$symbol: Nullable<TkAssign>;
                let $scope$e: Nullable<exp>;
                let $$res: Nullable<array> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$p1 = this.matchTkOpenBracket($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$type = this.matchType($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$p2 = this.matchTkCloseBracket($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$id = this.matchTkId($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$symbol = this.matchTkAssign($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$e = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && this.matchTkSemicolon($$dpth + 1, $$cr) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                ) {
                    $$res = {kind: ASTKinds.array, p1: $scope$p1, type: $scope$type, p2: $scope$p2, id: $scope$id, symbol: $scope$symbol, e: $scope$e};
                }
                return $$res;
            });
    }
    public matchunary($$dpth: number, $$cr?: ErrorTracker): Nullable<unary> {
        return this.choice<unary>([
            () => this.matchunary_1($$dpth + 1, $$cr),
            () => this.matchunary_2($$dpth + 1, $$cr),
            () => this.matchunary_3($$dpth + 1, $$cr),
        ]);
    }
    public matchunary_1($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_1> {
        return this.matchTkPlus($$dpth + 1, $$cr);
    }
    public matchunary_2($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_2> {
        return this.matchTkMinus($$dpth + 1, $$cr);
    }
    public matchunary_3($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_3> {
        return this.matchTkNot($$dpth + 1, $$cr);
    }
    public matchterms($$dpth: number, $$cr?: ErrorTracker): Nullable<terms> {
        return this.choice<terms>([
            () => this.matchterms_1($$dpth + 1, $$cr),
            () => this.matchterms_2($$dpth + 1, $$cr),
            () => this.matchterms_3($$dpth + 1, $$cr),
        ]);
    }
    public matchterms_1($$dpth: number, $$cr?: ErrorTracker): Nullable<terms_1> {
        return this.matchTkNumber($$dpth + 1, $$cr);
    }
    public matchterms_2($$dpth: number, $$cr?: ErrorTracker): Nullable<terms_2> {
        return this.matchTkBoolean($$dpth + 1, $$cr);
    }
    public matchterms_3($$dpth: number, $$cr?: ErrorTracker): Nullable<terms_3> {
        return this.run<terms_3>($$dpth,
            () => {
                let $scope$value: Nullable<TkId>;
                let $scope$a: Nullable<Nullable<terms_$0>>;
                let $scope$b: Nullable<Nullable<terms_$1>>;
                let $$res: Nullable<terms_3> = null;
                if (true
                    && ($scope$value = this.matchTkId($$dpth + 1, $$cr)) !== null
                    && (($scope$a = this.matchterms_$0($$dpth + 1, $$cr)) || true)
                    && (($scope$b = this.matchterms_$1($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.terms_3, value: $scope$value, a: $scope$a, b: $scope$b};
                }
                return $$res;
            });
    }
    public matchterms_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<terms_$0> {
        return this.run<terms_$0>($$dpth,
            () => {
                let $scope$next: Nullable<exp>;
                let $$res: Nullable<terms_$0> = null;
                if (true
                    && this.matchTkOpenBracket($$dpth + 1, $$cr) !== null
                    && ($scope$next = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.matchTkCloseBracket($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.terms_$0, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchterms_$1($$dpth: number, $$cr?: ErrorTracker): Nullable<terms_$1> {
        return this.run<terms_$1>($$dpth,
            () => {
                let $scope$next: Nullable<Nullable<termino>>;
                let $$res: Nullable<terms_$1> = null;
                if (true
                    && this.matchTkOpenPar($$dpth + 1, $$cr) !== null
                    && (($scope$next = this.matchtermino($$dpth + 1, $$cr)) || true)
                    && this.matchTkClosePar($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.terms_$1, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchexp($$dpth: number, $$cr?: ErrorTracker): Nullable<exp> {
        return this.run<exp>($$dpth,
            () => {
                let $scope$e: Nullable<e1>;
                let $$res: Nullable<exp> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$e = this.matche1($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                ) {
                    $$res = {kind: ASTKinds.exp, e: $scope$e};
                }
                return $$res;
            });
    }
    public matche1($$dpth: number, $$cr?: ErrorTracker): Nullable<e1> {
        return this.run<e1>($$dpth,
            () => {
                let $scope$e: Nullable<e2>;
                let $scope$a: Nullable<e1_$0[]>;
                let $$res: Nullable<e1> = null;
                if (true
                    && ($scope$e = this.matche2($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$a = this.loop<e1_$0>(() => this.matche1_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.e1, e: $scope$e, a: $scope$a};
                }
                return $$res;
            });
    }
    public matche1_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e1_$0> {
        return this.run<e1_$0>($$dpth,
            () => {
                let $scope$op: Nullable<e1_$0_$0>;
                let $scope$next: Nullable<e2>;
                let $$res: Nullable<e1_$0> = null;
                if (true
                    && ($scope$op = this.matche1_$0_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.matche2($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.e1_$0, op: $scope$op, next: $scope$next};
                }
                return $$res;
            });
    }
    public matche1_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e1_$0_$0> {
        return this.choice<e1_$0_$0>([
            () => this.matche1_$0_$0_1($$dpth + 1, $$cr),
            () => this.matche1_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matche1_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<e1_$0_$0_1> {
        return this.matchTkAnd($$dpth + 1, $$cr);
    }
    public matche1_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<e1_$0_$0_2> {
        return this.matchTkOr($$dpth + 1, $$cr);
    }
    public matche2($$dpth: number, $$cr?: ErrorTracker): Nullable<e2> {
        return this.run<e2>($$dpth,
            () => {
                let $scope$e: Nullable<e3>;
                let $scope$a: Nullable<e2_$0[]>;
                let $$res: Nullable<e2> = null;
                if (true
                    && ($scope$e = this.matche3($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$a = this.loop<e2_$0>(() => this.matche2_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.e2, e: $scope$e, a: $scope$a};
                }
                return $$res;
            });
    }
    public matche2_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e2_$0> {
        return this.run<e2_$0>($$dpth,
            () => {
                let $scope$op: Nullable<e2_$0_$0>;
                let $scope$next: Nullable<e3>;
                let $$res: Nullable<e2_$0> = null;
                if (true
                    && ($scope$op = this.matche2_$0_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.matche3($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.e2_$0, op: $scope$op, next: $scope$next};
                }
                return $$res;
            });
    }
    public matche2_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e2_$0_$0> {
        return this.choice<e2_$0_$0>([
            () => this.matche2_$0_$0_1($$dpth + 1, $$cr),
            () => this.matche2_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matche2_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<e2_$0_$0_1> {
        return this.matchTkEQ($$dpth + 1, $$cr);
    }
    public matche2_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<e2_$0_$0_2> {
        return this.matchTkNE($$dpth + 1, $$cr);
    }
    public matche3($$dpth: number, $$cr?: ErrorTracker): Nullable<e3> {
        return this.run<e3>($$dpth,
            () => {
                let $scope$e: Nullable<e4>;
                let $scope$a: Nullable<e3_$0[]>;
                let $$res: Nullable<e3> = null;
                if (true
                    && ($scope$e = this.matche4($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$a = this.loop<e3_$0>(() => this.matche3_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.e3, e: $scope$e, a: $scope$a};
                }
                return $$res;
            });
    }
    public matche3_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e3_$0> {
        return this.run<e3_$0>($$dpth,
            () => {
                let $scope$op: Nullable<e3_$0_$0>;
                let $scope$next: Nullable<e4>;
                let $$res: Nullable<e3_$0> = null;
                if (true
                    && ($scope$op = this.matche3_$0_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.matche4($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.e3_$0, op: $scope$op, next: $scope$next};
                }
                return $$res;
            });
    }
    public matche3_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e3_$0_$0> {
        return this.choice<e3_$0_$0>([
            () => this.matche3_$0_$0_1($$dpth + 1, $$cr),
            () => this.matche3_$0_$0_2($$dpth + 1, $$cr),
            () => this.matche3_$0_$0_3($$dpth + 1, $$cr),
            () => this.matche3_$0_$0_4($$dpth + 1, $$cr),
        ]);
    }
    public matche3_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<e3_$0_$0_1> {
        return this.matchTkLT($$dpth + 1, $$cr);
    }
    public matche3_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<e3_$0_$0_2> {
        return this.matchTkLE($$dpth + 1, $$cr);
    }
    public matche3_$0_$0_3($$dpth: number, $$cr?: ErrorTracker): Nullable<e3_$0_$0_3> {
        return this.matchTkGE($$dpth + 1, $$cr);
    }
    public matche3_$0_$0_4($$dpth: number, $$cr?: ErrorTracker): Nullable<e3_$0_$0_4> {
        return this.matchTkGT($$dpth + 1, $$cr);
    }
    public matche4($$dpth: number, $$cr?: ErrorTracker): Nullable<e4> {
        return this.run<e4>($$dpth,
            () => {
                let $scope$e: Nullable<e5>;
                let $scope$a: Nullable<e4_$0[]>;
                let $$res: Nullable<e4> = null;
                if (true
                    && ($scope$e = this.matche5($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$a = this.loop<e4_$0>(() => this.matche4_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.e4, e: $scope$e, a: $scope$a};
                }
                return $$res;
            });
    }
    public matche4_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e4_$0> {
        return this.run<e4_$0>($$dpth,
            () => {
                let $scope$op: Nullable<e4_$0_$0>;
                let $scope$next: Nullable<e5>;
                let $$res: Nullable<e4_$0> = null;
                if (true
                    && ($scope$op = this.matche4_$0_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.matche5($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.e4_$0, op: $scope$op, next: $scope$next};
                }
                return $$res;
            });
    }
    public matche4_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e4_$0_$0> {
        return this.choice<e4_$0_$0>([
            () => this.matche4_$0_$0_1($$dpth + 1, $$cr),
            () => this.matche4_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matche4_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<e4_$0_$0_1> {
        return this.matchTkPlus($$dpth + 1, $$cr);
    }
    public matche4_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<e4_$0_$0_2> {
        return this.matchTkMinus($$dpth + 1, $$cr);
    }
    public matche5($$dpth: number, $$cr?: ErrorTracker): Nullable<e5> {
        return this.run<e5>($$dpth,
            () => {
                let $scope$e: Nullable<e6>;
                let $scope$a: Nullable<e5_$0[]>;
                let $$res: Nullable<e5> = null;
                if (true
                    && ($scope$e = this.matche6($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$a = this.loop<e5_$0>(() => this.matche5_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.e5, e: $scope$e, a: $scope$a};
                }
                return $$res;
            });
    }
    public matche5_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e5_$0> {
        return this.run<e5_$0>($$dpth,
            () => {
                let $scope$op: Nullable<e5_$0_$0>;
                let $scope$next: Nullable<e6>;
                let $$res: Nullable<e5_$0> = null;
                if (true
                    && ($scope$op = this.matche5_$0_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.matche6($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.e5_$0, op: $scope$op, next: $scope$next};
                }
                return $$res;
            });
    }
    public matche5_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e5_$0_$0> {
        return this.choice<e5_$0_$0>([
            () => this.matche5_$0_$0_1($$dpth + 1, $$cr),
            () => this.matche5_$0_$0_2($$dpth + 1, $$cr),
            () => this.matche5_$0_$0_3($$dpth + 1, $$cr),
        ]);
    }
    public matche5_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<e5_$0_$0_1> {
        return this.matchTkMult($$dpth + 1, $$cr);
    }
    public matche5_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<e5_$0_$0_2> {
        return this.matchTkDiv($$dpth + 1, $$cr);
    }
    public matche5_$0_$0_3($$dpth: number, $$cr?: ErrorTracker): Nullable<e5_$0_$0_3> {
        return this.matchTkMod($$dpth + 1, $$cr);
    }
    public matche6($$dpth: number, $$cr?: ErrorTracker): Nullable<e6> {
        return this.run<e6>($$dpth,
            () => {
                let $scope$uop: Nullable<unary[]>;
                let $scope$e: Nullable<e7>;
                let $$res: Nullable<e6> = null;
                if (true
                    && ($scope$uop = this.loop<unary>(() => this.matchunary($$dpth + 1, $$cr), true)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$e = this.matche7($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                ) {
                    $$res = {kind: ASTKinds.e6, uop: $scope$uop, e: $scope$e};
                }
                return $$res;
            });
    }
    public matche7($$dpth: number, $$cr?: ErrorTracker): Nullable<e7> {
        return this.run<e7>($$dpth,
            () => {
                let $scope$e: Nullable<e8>;
                let $scope$a: Nullable<e7_$0[]>;
                let $$res: Nullable<e7> = null;
                if (true
                    && ($scope$e = this.matche8($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$a = this.loop<e7_$0>(() => this.matche7_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.e7, e: $scope$e, a: $scope$a};
                }
                return $$res;
            });
    }
    public matche7_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e7_$0> {
        return this.run<e7_$0>($$dpth,
            () => {
                let $scope$op: Nullable<e7_$0_$0>;
                let $scope$next: Nullable<e8>;
                let $$res: Nullable<e7_$0> = null;
                if (true
                    && ($scope$op = this.matche7_$0_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.matche8($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.e7_$0, op: $scope$op, next: $scope$next};
                }
                return $$res;
            });
    }
    public matche7_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<e7_$0_$0> {
        return this.matchTkPower($$dpth + 1, $$cr);
    }
    public matche8($$dpth: number, $$cr?: ErrorTracker): Nullable<e8> {
        return this.choice<e8>([
            () => this.matche8_1($$dpth + 1, $$cr),
            () => this.matche8_2($$dpth + 1, $$cr),
            () => this.matche8_3($$dpth + 1, $$cr),
            () => this.matche8_4($$dpth + 1, $$cr),
            () => this.matche8_5($$dpth + 1, $$cr),
        ]);
    }
    public matche8_1($$dpth: number, $$cr?: ErrorTracker): Nullable<e8_1> {
        return this.run<e8_1>($$dpth,
            () => {
                let $scope$value: Nullable<exp>;
                let $$res: Nullable<e8_1> = null;
                if (true
                    && this.matchTkOpenPar($$dpth + 1, $$cr) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && this.matchTkClosePar($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.e8_1, value: $scope$value};
                }
                return $$res;
            });
    }
    public matche8_2($$dpth: number, $$cr?: ErrorTracker): Nullable<e8_2> {
        return this.run<e8_2>($$dpth,
            () => {
                let $scope$value: Nullable<Nullable<termino>>;
                let $$res: Nullable<e8_2> = null;
                if (true
                    && this.matchTkOpenBracket($$dpth + 1, $$cr) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && (($scope$value = this.matchtermino($$dpth + 1, $$cr)) || true)
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && this.matchTkCloseBracket($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.e8_2, value: $scope$value};
                }
                return $$res;
            });
    }
    public matche8_3($$dpth: number, $$cr?: ErrorTracker): Nullable<e8_3> {
        return this.run<e8_3>($$dpth,
            () => {
                let $scope$value: Nullable<exp>;
                let $$res: Nullable<e8_3> = null;
                if (true
                    && this.matchTkOpenBrace($$dpth + 1, $$cr) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && this.matchTkCloseBrace($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.e8_3, value: $scope$value};
                }
                return $$res;
            });
    }
    public matche8_4($$dpth: number, $$cr?: ErrorTracker): Nullable<e8_4> {
        return this.run<e8_4>($$dpth,
            () => {
                let $scope$value: Nullable<exp>;
                let $$res: Nullable<e8_4> = null;
                if (true
                    && this.matchTkQuote($$dpth + 1, $$cr) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && this.matchTkQuote($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.e8_4, value: $scope$value};
                }
                return $$res;
            });
    }
    public matche8_5($$dpth: number, $$cr?: ErrorTracker): Nullable<e8_5> {
        return this.matchterms($$dpth + 1, $$cr);
    }
    public matchtermino($$dpth: number, $$cr?: ErrorTracker): Nullable<termino> {
        return this.run<termino>($$dpth,
            () => {
                let $scope$e: Nullable<exp>;
                let $scope$b: Nullable<termino_$0[]>;
                let $$res: Nullable<termino> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$e = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$b = this.loop<termino_$0>(() => this.matchtermino_$0($$dpth + 1, $$cr), true)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                ) {
                    $$res = {kind: ASTKinds.termino, e: $scope$e, b: $scope$b};
                }
                return $$res;
            });
    }
    public matchtermino_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<termino_$0> {
        return this.run<termino_$0>($$dpth,
            () => {
                let $scope$e: Nullable<exp>;
                let $$res: Nullable<termino_$0> = null;
                if (true
                    && this.matchTkComma($$dpth + 1, $$cr) !== null
                    && ($scope$e = this.matchexp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.termino_$0, e: $scope$e};
                }
                return $$res;
            });
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchstart(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchstart(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchstart(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<start>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}