/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* start := start = recursive space* $
* recursive := TkNumber | TkFalse | TkTrue | TkNum | TkBool | TkId | TkAssign | TkColon | TkSemicolon | TkComma | TkQuote | TkNot | TkOpenPar | TkClosePar | TkOpenBracket | TkCloseBracket | TkOpenBrace | TkCloseBrace | TkOr | TkAnd | TkPower | TkDiv | TkPlus | TkMult | TkMod | TkMinus | TkLE | TkNE | TkLT | TkGE | TkGT | TkEQ 
* TkNumber := space* value = '[0-9]+(?:\.[0-9]+)?' next=recursive*
* TkNum := space* value = 'num' !'[a-zA-Z0-9_]' next=recursive*
* TkBool := space* value = 'bool' !'[a-zA-Z0-9_]' next=recursive*
* TkFalse := space* value = 'false' next=recursive*
* TkTrue := space* value = 'true' next=recursive*
* TkId := space* value = '\b([a-zA-Z_][^\s\W]*)' next=recursive*
* TkPlus := space* value = '\+' next=recursive*
* TkMult := space* value = '\*' next=recursive*
* TkOpenPar := space* value = '\(' next=recursive*
* TkClosePar := space* value = '\)' next=recursive*
* TkOpenBracket := space* value = '\[' next=recursive*
* TkCloseBracket := space* value = '\]' next=recursive*
* TkOpenBrace := space* value = '\{' next=recursive*
* TkCloseBrace := space* value = '\}' next=recursive*
* TkNot := space* value = '\!' next=recursive*
* TkPower := space* value = '\^' next=recursive*
* TkDiv := space* value = '\/' next=recursive*
* TkMod := space* value = '\%' next=recursive*
* TkMinus := space* value = '\-' next=recursive*
* TkLT := space* value = '\<' next=recursive*
* TkLE := space* value = '\<=' next=recursive*
* TkGE := space* value = '\>=' next=recursive*
* TkGT := space* value = '\>' next=recursive*
* TkEQ := space* value = '\=' next=recursive*
* TkNE := space* value = '\<>' next=recursive*
* TkAnd := space* value = '\&\&' next=recursive*
* TkOr := space* value = '\|\|' next=recursive*
* TkQuote := space* value = '\'' next=recursive*
* TkComma := space* value = '\,' next=recursive*
* TkSemicolon := space* value = '\;' next=recursive*
* TkColon := space* value = '\:' next=recursive*
* TkAssign := space* value = '\:=' next=recursive*
* space := ' ' | '\\t' | '\n' | '\r\n' | '[" "]+'
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    start = "start",
    recursive_1 = "recursive_1",
    recursive_2 = "recursive_2",
    recursive_3 = "recursive_3",
    recursive_4 = "recursive_4",
    recursive_5 = "recursive_5",
    recursive_6 = "recursive_6",
    recursive_7 = "recursive_7",
    recursive_8 = "recursive_8",
    recursive_9 = "recursive_9",
    recursive_10 = "recursive_10",
    recursive_11 = "recursive_11",
    recursive_12 = "recursive_12",
    recursive_13 = "recursive_13",
    recursive_14 = "recursive_14",
    recursive_15 = "recursive_15",
    recursive_16 = "recursive_16",
    recursive_17 = "recursive_17",
    recursive_18 = "recursive_18",
    recursive_19 = "recursive_19",
    recursive_20 = "recursive_20",
    recursive_21 = "recursive_21",
    recursive_22 = "recursive_22",
    recursive_23 = "recursive_23",
    recursive_24 = "recursive_24",
    recursive_25 = "recursive_25",
    recursive_26 = "recursive_26",
    recursive_27 = "recursive_27",
    recursive_28 = "recursive_28",
    recursive_29 = "recursive_29",
    recursive_30 = "recursive_30",
    recursive_31 = "recursive_31",
    recursive_32 = "recursive_32",
    TkNumber = "TkNumber",
    TkNum = "TkNum",
    TkBool = "TkBool",
    TkFalse = "TkFalse",
    TkTrue = "TkTrue",
    TkId = "TkId",
    TkPlus = "TkPlus",
    TkMult = "TkMult",
    TkOpenPar = "TkOpenPar",
    TkClosePar = "TkClosePar",
    TkOpenBracket = "TkOpenBracket",
    TkCloseBracket = "TkCloseBracket",
    TkOpenBrace = "TkOpenBrace",
    TkCloseBrace = "TkCloseBrace",
    TkNot = "TkNot",
    TkPower = "TkPower",
    TkDiv = "TkDiv",
    TkMod = "TkMod",
    TkMinus = "TkMinus",
    TkLT = "TkLT",
    TkLE = "TkLE",
    TkGE = "TkGE",
    TkGT = "TkGT",
    TkEQ = "TkEQ",
    TkNE = "TkNE",
    TkAnd = "TkAnd",
    TkOr = "TkOr",
    TkQuote = "TkQuote",
    TkComma = "TkComma",
    TkSemicolon = "TkSemicolon",
    TkColon = "TkColon",
    TkAssign = "TkAssign",
    space_1 = "space_1",
    space_2 = "space_2",
    space_3 = "space_3",
    space_4 = "space_4",
    space_5 = "space_5",
    $EOF = "$EOF",
}
export interface start {
    kind: ASTKinds.start;
    start: recursive;
}
export type recursive = recursive_1 | recursive_2 | recursive_3 | recursive_4 | recursive_5 | recursive_6 | recursive_7 | recursive_8 | recursive_9 | recursive_10 | recursive_11 | recursive_12 | recursive_13 | recursive_14 | recursive_15 | recursive_16 | recursive_17 | recursive_18 | recursive_19 | recursive_20 | recursive_21 | recursive_22 | recursive_23 | recursive_24 | recursive_25 | recursive_26 | recursive_27 | recursive_28 | recursive_29 | recursive_30 | recursive_31 | recursive_32;
export type recursive_1 = TkNumber;
export type recursive_2 = TkFalse;
export type recursive_3 = TkTrue;
export type recursive_4 = TkNum;
export type recursive_5 = TkBool;
export type recursive_6 = TkId;
export type recursive_7 = TkAssign;
export type recursive_8 = TkColon;
export type recursive_9 = TkSemicolon;
export type recursive_10 = TkComma;
export type recursive_11 = TkQuote;
export type recursive_12 = TkNot;
export type recursive_13 = TkOpenPar;
export type recursive_14 = TkClosePar;
export type recursive_15 = TkOpenBracket;
export type recursive_16 = TkCloseBracket;
export type recursive_17 = TkOpenBrace;
export type recursive_18 = TkCloseBrace;
export type recursive_19 = TkOr;
export type recursive_20 = TkAnd;
export type recursive_21 = TkPower;
export type recursive_22 = TkDiv;
export type recursive_23 = TkPlus;
export type recursive_24 = TkMult;
export type recursive_25 = TkMod;
export type recursive_26 = TkMinus;
export type recursive_27 = TkLE;
export type recursive_28 = TkNE;
export type recursive_29 = TkLT;
export type recursive_30 = TkGE;
export type recursive_31 = TkGT;
export type recursive_32 = TkEQ;
export interface TkNumber {
    kind: ASTKinds.TkNumber;
    value: string;
    next: recursive[];
}
export interface TkNum {
    kind: ASTKinds.TkNum;
    value: string;
    next: recursive[];
}
export interface TkBool {
    kind: ASTKinds.TkBool;
    value: string;
    next: recursive[];
}
export interface TkFalse {
    kind: ASTKinds.TkFalse;
    value: string;
    next: recursive[];
}
export interface TkTrue {
    kind: ASTKinds.TkTrue;
    value: string;
    next: recursive[];
}
export interface TkId {
    kind: ASTKinds.TkId;
    value: string;
    next: recursive[];
}
export interface TkPlus {
    kind: ASTKinds.TkPlus;
    value: string;
    next: recursive[];
}
export interface TkMult {
    kind: ASTKinds.TkMult;
    value: string;
    next: recursive[];
}
export interface TkOpenPar {
    kind: ASTKinds.TkOpenPar;
    value: string;
    next: recursive[];
}
export interface TkClosePar {
    kind: ASTKinds.TkClosePar;
    value: string;
    next: recursive[];
}
export interface TkOpenBracket {
    kind: ASTKinds.TkOpenBracket;
    value: string;
    next: recursive[];
}
export interface TkCloseBracket {
    kind: ASTKinds.TkCloseBracket;
    value: string;
    next: recursive[];
}
export interface TkOpenBrace {
    kind: ASTKinds.TkOpenBrace;
    value: string;
    next: recursive[];
}
export interface TkCloseBrace {
    kind: ASTKinds.TkCloseBrace;
    value: string;
    next: recursive[];
}
export interface TkNot {
    kind: ASTKinds.TkNot;
    value: string;
    next: recursive[];
}
export interface TkPower {
    kind: ASTKinds.TkPower;
    value: string;
    next: recursive[];
}
export interface TkDiv {
    kind: ASTKinds.TkDiv;
    value: string;
    next: recursive[];
}
export interface TkMod {
    kind: ASTKinds.TkMod;
    value: string;
    next: recursive[];
}
export interface TkMinus {
    kind: ASTKinds.TkMinus;
    value: string;
    next: recursive[];
}
export interface TkLT {
    kind: ASTKinds.TkLT;
    value: string;
    next: recursive[];
}
export interface TkLE {
    kind: ASTKinds.TkLE;
    value: string;
    next: recursive[];
}
export interface TkGE {
    kind: ASTKinds.TkGE;
    value: string;
    next: recursive[];
}
export interface TkGT {
    kind: ASTKinds.TkGT;
    value: string;
    next: recursive[];
}
export interface TkEQ {
    kind: ASTKinds.TkEQ;
    value: string;
    next: recursive[];
}
export interface TkNE {
    kind: ASTKinds.TkNE;
    value: string;
    next: recursive[];
}
export interface TkAnd {
    kind: ASTKinds.TkAnd;
    value: string;
    next: recursive[];
}
export interface TkOr {
    kind: ASTKinds.TkOr;
    value: string;
    next: recursive[];
}
export interface TkQuote {
    kind: ASTKinds.TkQuote;
    value: string;
    next: recursive[];
}
export interface TkComma {
    kind: ASTKinds.TkComma;
    value: string;
    next: recursive[];
}
export interface TkSemicolon {
    kind: ASTKinds.TkSemicolon;
    value: string;
    next: recursive[];
}
export interface TkColon {
    kind: ASTKinds.TkColon;
    value: string;
    next: recursive[];
}
export interface TkAssign {
    kind: ASTKinds.TkAssign;
    value: string;
    next: recursive[];
}
export type space = space_1 | space_2 | space_3 | space_4 | space_5;
export type space_1 = string;
export type space_2 = string;
export type space_3 = string;
export type space_4 = string;
export type space_5 = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchstart($$dpth: number, $$cr?: ErrorTracker): Nullable<start> {
        return this.run<start>($$dpth,
            () => {
                let $scope$start: Nullable<recursive>;
                let $$res: Nullable<start> = null;
                if (true
                    && ($scope$start = this.matchrecursive($$dpth + 1, $$cr)) !== null
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.start, start: $scope$start};
                }
                return $$res;
            });
    }
    public matchrecursive($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive> {
        return this.choice<recursive>([
            () => this.matchrecursive_1($$dpth + 1, $$cr),
            () => this.matchrecursive_2($$dpth + 1, $$cr),
            () => this.matchrecursive_3($$dpth + 1, $$cr),
            () => this.matchrecursive_4($$dpth + 1, $$cr),
            () => this.matchrecursive_5($$dpth + 1, $$cr),
            () => this.matchrecursive_6($$dpth + 1, $$cr),
            () => this.matchrecursive_7($$dpth + 1, $$cr),
            () => this.matchrecursive_8($$dpth + 1, $$cr),
            () => this.matchrecursive_9($$dpth + 1, $$cr),
            () => this.matchrecursive_10($$dpth + 1, $$cr),
            () => this.matchrecursive_11($$dpth + 1, $$cr),
            () => this.matchrecursive_12($$dpth + 1, $$cr),
            () => this.matchrecursive_13($$dpth + 1, $$cr),
            () => this.matchrecursive_14($$dpth + 1, $$cr),
            () => this.matchrecursive_15($$dpth + 1, $$cr),
            () => this.matchrecursive_16($$dpth + 1, $$cr),
            () => this.matchrecursive_17($$dpth + 1, $$cr),
            () => this.matchrecursive_18($$dpth + 1, $$cr),
            () => this.matchrecursive_19($$dpth + 1, $$cr),
            () => this.matchrecursive_20($$dpth + 1, $$cr),
            () => this.matchrecursive_21($$dpth + 1, $$cr),
            () => this.matchrecursive_22($$dpth + 1, $$cr),
            () => this.matchrecursive_23($$dpth + 1, $$cr),
            () => this.matchrecursive_24($$dpth + 1, $$cr),
            () => this.matchrecursive_25($$dpth + 1, $$cr),
            () => this.matchrecursive_26($$dpth + 1, $$cr),
            () => this.matchrecursive_27($$dpth + 1, $$cr),
            () => this.matchrecursive_28($$dpth + 1, $$cr),
            () => this.matchrecursive_29($$dpth + 1, $$cr),
            () => this.matchrecursive_30($$dpth + 1, $$cr),
            () => this.matchrecursive_31($$dpth + 1, $$cr),
            () => this.matchrecursive_32($$dpth + 1, $$cr),
        ]);
    }
    public matchrecursive_1($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_1> {
        return this.matchTkNumber($$dpth + 1, $$cr);
    }
    public matchrecursive_2($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_2> {
        return this.matchTkFalse($$dpth + 1, $$cr);
    }
    public matchrecursive_3($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_3> {
        return this.matchTkTrue($$dpth + 1, $$cr);
    }
    public matchrecursive_4($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_4> {
        return this.matchTkNum($$dpth + 1, $$cr);
    }
    public matchrecursive_5($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_5> {
        return this.matchTkBool($$dpth + 1, $$cr);
    }
    public matchrecursive_6($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_6> {
        return this.matchTkId($$dpth + 1, $$cr);
    }
    public matchrecursive_7($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_7> {
        return this.matchTkAssign($$dpth + 1, $$cr);
    }
    public matchrecursive_8($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_8> {
        return this.matchTkColon($$dpth + 1, $$cr);
    }
    public matchrecursive_9($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_9> {
        return this.matchTkSemicolon($$dpth + 1, $$cr);
    }
    public matchrecursive_10($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_10> {
        return this.matchTkComma($$dpth + 1, $$cr);
    }
    public matchrecursive_11($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_11> {
        return this.matchTkQuote($$dpth + 1, $$cr);
    }
    public matchrecursive_12($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_12> {
        return this.matchTkNot($$dpth + 1, $$cr);
    }
    public matchrecursive_13($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_13> {
        return this.matchTkOpenPar($$dpth + 1, $$cr);
    }
    public matchrecursive_14($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_14> {
        return this.matchTkClosePar($$dpth + 1, $$cr);
    }
    public matchrecursive_15($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_15> {
        return this.matchTkOpenBracket($$dpth + 1, $$cr);
    }
    public matchrecursive_16($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_16> {
        return this.matchTkCloseBracket($$dpth + 1, $$cr);
    }
    public matchrecursive_17($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_17> {
        return this.matchTkOpenBrace($$dpth + 1, $$cr);
    }
    public matchrecursive_18($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_18> {
        return this.matchTkCloseBrace($$dpth + 1, $$cr);
    }
    public matchrecursive_19($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_19> {
        return this.matchTkOr($$dpth + 1, $$cr);
    }
    public matchrecursive_20($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_20> {
        return this.matchTkAnd($$dpth + 1, $$cr);
    }
    public matchrecursive_21($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_21> {
        return this.matchTkPower($$dpth + 1, $$cr);
    }
    public matchrecursive_22($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_22> {
        return this.matchTkDiv($$dpth + 1, $$cr);
    }
    public matchrecursive_23($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_23> {
        return this.matchTkPlus($$dpth + 1, $$cr);
    }
    public matchrecursive_24($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_24> {
        return this.matchTkMult($$dpth + 1, $$cr);
    }
    public matchrecursive_25($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_25> {
        return this.matchTkMod($$dpth + 1, $$cr);
    }
    public matchrecursive_26($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_26> {
        return this.matchTkMinus($$dpth + 1, $$cr);
    }
    public matchrecursive_27($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_27> {
        return this.matchTkLE($$dpth + 1, $$cr);
    }
    public matchrecursive_28($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_28> {
        return this.matchTkNE($$dpth + 1, $$cr);
    }
    public matchrecursive_29($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_29> {
        return this.matchTkLT($$dpth + 1, $$cr);
    }
    public matchrecursive_30($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_30> {
        return this.matchTkGE($$dpth + 1, $$cr);
    }
    public matchrecursive_31($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_31> {
        return this.matchTkGT($$dpth + 1, $$cr);
    }
    public matchrecursive_32($$dpth: number, $$cr?: ErrorTracker): Nullable<recursive_32> {
        return this.matchTkEQ($$dpth + 1, $$cr);
    }
    public matchTkNumber($$dpth: number, $$cr?: ErrorTracker): Nullable<TkNumber> {
        return this.run<TkNumber>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkNumber> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:[0-9]+(?:\.[0-9]+)?)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkNumber, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkNum($$dpth: number, $$cr?: ErrorTracker): Nullable<TkNum> {
        return this.run<TkNum>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkNum> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:num)`, $$dpth + 1, $$cr)) !== null
                    && this.negate(() => this.regexAccept(String.raw`(?:[a-zA-Z0-9_])`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkNum, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkBool($$dpth: number, $$cr?: ErrorTracker): Nullable<TkBool> {
        return this.run<TkBool>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkBool> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:bool)`, $$dpth + 1, $$cr)) !== null
                    && this.negate(() => this.regexAccept(String.raw`(?:[a-zA-Z0-9_])`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkBool, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkFalse($$dpth: number, $$cr?: ErrorTracker): Nullable<TkFalse> {
        return this.run<TkFalse>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkFalse> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:false)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkFalse, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkTrue($$dpth: number, $$cr?: ErrorTracker): Nullable<TkTrue> {
        return this.run<TkTrue>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkTrue> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:true)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkTrue, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkId($$dpth: number, $$cr?: ErrorTracker): Nullable<TkId> {
        return this.run<TkId>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkId> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\b([a-zA-Z_][^\s\W]*))`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkId, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkPlus($$dpth: number, $$cr?: ErrorTracker): Nullable<TkPlus> {
        return this.run<TkPlus>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkPlus> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkPlus, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkMult($$dpth: number, $$cr?: ErrorTracker): Nullable<TkMult> {
        return this.run<TkMult>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkMult> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\*)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkMult, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkOpenPar($$dpth: number, $$cr?: ErrorTracker): Nullable<TkOpenPar> {
        return this.run<TkOpenPar>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkOpenPar> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkOpenPar, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkClosePar($$dpth: number, $$cr?: ErrorTracker): Nullable<TkClosePar> {
        return this.run<TkClosePar>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkClosePar> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkClosePar, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkOpenBracket($$dpth: number, $$cr?: ErrorTracker): Nullable<TkOpenBracket> {
        return this.run<TkOpenBracket>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkOpenBracket> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkOpenBracket, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkCloseBracket($$dpth: number, $$cr?: ErrorTracker): Nullable<TkCloseBracket> {
        return this.run<TkCloseBracket>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkCloseBracket> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkCloseBracket, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkOpenBrace($$dpth: number, $$cr?: ErrorTracker): Nullable<TkOpenBrace> {
        return this.run<TkOpenBrace>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkOpenBrace> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\{)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkOpenBrace, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkCloseBrace($$dpth: number, $$cr?: ErrorTracker): Nullable<TkCloseBrace> {
        return this.run<TkCloseBrace>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkCloseBrace> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\})`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkCloseBrace, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkNot($$dpth: number, $$cr?: ErrorTracker): Nullable<TkNot> {
        return this.run<TkNot>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkNot> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\!)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkNot, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkPower($$dpth: number, $$cr?: ErrorTracker): Nullable<TkPower> {
        return this.run<TkPower>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkPower> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\^)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkPower, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkDiv($$dpth: number, $$cr?: ErrorTracker): Nullable<TkDiv> {
        return this.run<TkDiv>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkDiv> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\/)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkDiv, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkMod($$dpth: number, $$cr?: ErrorTracker): Nullable<TkMod> {
        return this.run<TkMod>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkMod> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\%)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkMod, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<TkMinus> {
        return this.run<TkMinus>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkMinus> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\-)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkMinus, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkLT($$dpth: number, $$cr?: ErrorTracker): Nullable<TkLT> {
        return this.run<TkLT>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkLT> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\<)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkLT, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkLE($$dpth: number, $$cr?: ErrorTracker): Nullable<TkLE> {
        return this.run<TkLE>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkLE> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\<=)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkLE, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkGE($$dpth: number, $$cr?: ErrorTracker): Nullable<TkGE> {
        return this.run<TkGE>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkGE> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\>=)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkGE, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkGT($$dpth: number, $$cr?: ErrorTracker): Nullable<TkGT> {
        return this.run<TkGT>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkGT> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\>)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkGT, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkEQ($$dpth: number, $$cr?: ErrorTracker): Nullable<TkEQ> {
        return this.run<TkEQ>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkEQ> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\=)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkEQ, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkNE($$dpth: number, $$cr?: ErrorTracker): Nullable<TkNE> {
        return this.run<TkNE>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkNE> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\<>)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkNE, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<TkAnd> {
        return this.run<TkAnd>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkAnd> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\&\&)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkAnd, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkOr($$dpth: number, $$cr?: ErrorTracker): Nullable<TkOr> {
        return this.run<TkOr>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkOr> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\|\|)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkOr, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkQuote($$dpth: number, $$cr?: ErrorTracker): Nullable<TkQuote> {
        return this.run<TkQuote>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkQuote> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\')`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkQuote, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkComma($$dpth: number, $$cr?: ErrorTracker): Nullable<TkComma> {
        return this.run<TkComma>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkComma> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\,)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkComma, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkSemicolon($$dpth: number, $$cr?: ErrorTracker): Nullable<TkSemicolon> {
        return this.run<TkSemicolon>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkSemicolon> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\;)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkSemicolon, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkColon($$dpth: number, $$cr?: ErrorTracker): Nullable<TkColon> {
        return this.run<TkColon>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkColon> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\:)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkColon, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchTkAssign($$dpth: number, $$cr?: ErrorTracker): Nullable<TkAssign> {
        return this.run<TkAssign>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $scope$next: Nullable<recursive[]>;
                let $$res: Nullable<TkAssign> = null;
                if (true
                    && this.loop<space>(() => this.matchspace($$dpth + 1, $$cr), true) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:\:=)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$next = this.loop<recursive>(() => this.matchrecursive($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.TkAssign, value: $scope$value, next: $scope$next};
                }
                return $$res;
            });
    }
    public matchspace($$dpth: number, $$cr?: ErrorTracker): Nullable<space> {
        return this.choice<space>([
            () => this.matchspace_1($$dpth + 1, $$cr),
            () => this.matchspace_2($$dpth + 1, $$cr),
            () => this.matchspace_3($$dpth + 1, $$cr),
            () => this.matchspace_4($$dpth + 1, $$cr),
            () => this.matchspace_5($$dpth + 1, $$cr),
        ]);
    }
    public matchspace_1($$dpth: number, $$cr?: ErrorTracker): Nullable<space_1> {
        return this.regexAccept(String.raw`(?: )`, $$dpth + 1, $$cr);
    }
    public matchspace_2($$dpth: number, $$cr?: ErrorTracker): Nullable<space_2> {
        return this.regexAccept(String.raw`(?:\\t)`, $$dpth + 1, $$cr);
    }
    public matchspace_3($$dpth: number, $$cr?: ErrorTracker): Nullable<space_3> {
        return this.regexAccept(String.raw`(?:\n)`, $$dpth + 1, $$cr);
    }
    public matchspace_4($$dpth: number, $$cr?: ErrorTracker): Nullable<space_4> {
        return this.regexAccept(String.raw`(?:\r\n)`, $$dpth + 1, $$cr);
    }
    public matchspace_5($$dpth: number, $$cr?: ErrorTracker): Nullable<space_5> {
        return this.regexAccept(String.raw`(?:[" "]+)`, $$dpth + 1, $$cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchstart(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchstart(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchstart(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<start>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}